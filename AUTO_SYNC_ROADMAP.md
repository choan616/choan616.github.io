# Google Drive 자동 동기화 고도화 로드맵

## 📋 현재 상태 분석

### 기존 시스템
- ✅ Google Drive API 연동 완료 (`googleDrive.js`)
- ✅ 수동 백업/복원 기능 (`BackupPanel.jsx`)
- ✅ IndexedDB 기반 로컬 데이터 저장 (`db.js`)
- ✅ Google OAuth 인증
- ✅ JSON 형식 백업 파일 관리

### 제약 사항
- ❌ 사용자가 수동으로 백업 패널을 열어야 함
- ❌ 동기화 시점에 대한 자동화 없음
- ❌ 로컬 변경 사항 자동 감지 없음
- ❌ 네트워크 상태 고려 없음
- ❌ 충돌 해결 메커니즘 부재

---

## 🎯 목표

앱 접속 시 자동으로 Google Drive와 동기화되어, 사용자가 별도 작업 없이도 **모든 디바이스에서 최신 데이터**를 유지할 수 있도록 개선

---

## 🗺️ 단계별 로드맵

### Phase 1: 자동 동기화 기반 구축 (1-2주)

#### 1.1 동기화 상태 관리 시스템
**목표**: 동기화 상태를 중앙에서 관리하고 UI에 반영

- [x] **SyncManager 클래스 생성** (`src/services/syncManager.js`)
  - 동기화 상태 관리 (idle, syncing, error, success)
  - 마지막 동기화 시간 추적
  - 로컬 변경 사항 감지 플래그

- [x] **React Context 구성** (`src/contexts/SyncContext.jsx`)
  - 전역 동기화 상태 공유
  - 동기화 트리거 함수 제공
  - 실시간 상태 업데이트

#### 1.2 자동 동기화 트리거 구현
**목표**: 앱 접속 시 자동으로 동기화 실행

- [x] **앱 시작 시 동기화**
  - `App.jsx`에서 마운트 시 동기화 시작 (수동 로그인 시)
  - 인증 여부 확인 및 자동 로그인 시도
  - 백그라운드에서 조용히 실행

- [x] **주기적 동기화**
  - 설정 가능한 자동 동기화 간격 (예: 5분, 15분, 30분)
  - 앱이 활성 상태일 때만 실행
  - 사용자 설정으로 활성화/비활성화 가능

- [x] **로컬 변경 시 동기화**
  - IndexedDB 변경 감지 (Dexie hooks 활용)
  - Debounce 처리로 과도한 동기화 방지
  - 변경 사항 누적 후 일괄 업로드

#### 1.3 네트워크 상태 체크
**목표**: 네트워크 환경에 따라 동기화 동작 최적화

- [x] **온라인/오프라인 감지**
  - `navigator.onLine` API 활용
  - 네트워크 변경 이벤트 리스너
  - 오프라인 시 동기화 대기열에 추가

- [ ] **네트워크 품질 고려**
  - Slow 3G 등 느린 연결 감지
  - 네트워크 상태에 따라 동기화 전략 조정

---

### Phase 2: 양방향 동기화 및 충돌 해결 (2-3주)

#### 2.1 변경 사항 추적 시스템
**목표**: 로컬과 원격의 변경 사항을 정확히 추적

- [x] **메타데이터 추가**
  - 각 일기 항목에 타임스탬프 추가 (`createdAt`, `updatedAt`, `syncedAt`)
  - 버전 번호 또는 해시값으로 변경 감지
  - 삭제된 항목 추적 (soft delete) - `deletedAt` 필드 사용

- [x] **LastSync 저장소**
  - IndexedDB에 동기화 메타데이터 저장 (`syncMetadata` 테이블)
  - 마지막 동기화 시간, 원격 파일 ID, 마지막 동기화 기기 ID 기록

#### 2.2 양방향 동기화 로직
**목표**: 로컬 → 원격, 원격 → 로컬 모두 처리

- [x] **Pull 동기화 (원격 → 로컬)**
  - Google Drive에서 최신 백업 파일 확인
  - 로컬 데이터보다 최신인 경우, 전체 데이터(스냅샷)를 다운로드하여 병합

- [x] **Push 동기화 (로컬 → 원격)**
  - 로컬에 변경 사항이 있을 경우, 전체 데이터를 압축(스냅샷)하여 Google Drive에 업로드

#### 2.3 충돌 해결 메커니즘
**목표**: 여러 디바이스에서 동시 편집 시 데이터 손실 방지

- [x] **충돌 감지**
  - 동일 항목에 대한 로컬/원격 변경 비교
  - 마지막 동기화 시간과 로컬/원격의 최종 수정 시간을 비교하여 충돌 판단

- [x] **충돌 해결 정책 (수동)**
  - 데이터 유실 방지를 위해 자동 해결(예: Last-Write-Wins) 대신 동기화를 중단
  - 사용자에게 충돌 상황을 알리고, '백업(Push)' 또는 '복원(Pull)'을 직접 선택하여 해결하도록 유도

- [x] **수동 해결 UI**
  - `BackupPanel`에 충돌 상태와 해결 가이드라인을 명확히 표시
  - 사용자가 '지금 백업하기' 또는 '복원' 버튼을 통해 직접 충돌 해결
  - 충돌 해결 후, 동기화 상태가 자동으로 정상 업데이트됨

---

### Phase 3: 사용자 경험 개선 (1-2주)

#### 3.1 동기화 상태 표시
**목표**: 사용자가 동기화 상태를 쉽게 파악

- [x] **상태 인디케이터**
  - 헤더/하단에 동기화 아이콘 추가 (UserProfileButton에 통합)
  - 실시간 상태 표시 (동기화 중, 성공, 오류) - SyncIndicator.jsx
  - 마지막 동기화 시간 표시

- [ ] **진행률 표시**
  - 대용량 동기화 시 진행률 바
  - 업로드/다운로드 속도 표시 (선택적)

- [x] **토스트 알림 최적화**
  - 성공 시 조용한 알림 (자동 동기화는 토스트 없음)
  - 오류 시 명확한 메시지와 해결방법 제시
  - 수동 동기화 시 명확한 성공/실패 피드백

#### 3.2 설정 페이지 추가
**목표**: 사용자가 동기화 동작을 제어

- [x] **설정 UI 구성** (`src/components/Settings.jsx`)
  - 자동 동기화 활성화/비활성화
  - 동기화 간격 설정 (5분/15분/30분/1시간)
  - 저장 시 동기화 옵션
  - Wi-Fi에서만 동기화 옵션

- [x] **설정 저장**
  - LocalStorage에 저장
  - 설정 변경 시 즉시 반영 (CustomEvent 발송)

#### 3.3 오프라인 지원 강화
**목표**: 오프라인에서도 완벽하게 작동

- [x] **오프라인 큐**
  - 오프라인 시 동기화 작업 대기열에 추가 (localStorage)
  - 온라인 복귀 시 자동 실행
  - 재시도 로직 (exponential backoff) 기존 활용

- [x] **오프라인 모드 표시**
  - 오프라인 상태 명확히 표시 (OfflineBanner)
  - 대기 중인 동기화 개수 표시
  - 재연결 시 자동 동기화 안내

---

### Phase 4: 최적화 및 고급 기능 (2-3주)

#### 4.1 성능 최적화
**목표**: 동기화 속도 및 효율성 개선

- [x] **스냅샷 동기화 방식 채택**
  - 데이터 정합성과 이미지 동기화 안정성을 위해, 변경된 내역만 보내는 '증분 동기화' 대신 전체 데이터를 압축하여 동기화하는 '스냅샷' 방식을 채택.

- [ ] **압축**
  - JSON 데이터 gzip 압축
  - 이미지는 이미 압축되어 있으므로 제외

- [ ] **배치 처리**
  - 여러 변경 사항을 하나의 요청으로 통합
  - API 호출 횟수 최소화

- [ ] **캐싱**
  - 다운로드한 데이터 캐싱
  - 불필요한 재다운로드 방지

#### 4.2 백업 버전 관리
**목표**: 여러 버전 관리 및 복원 지원

- [ ] **스냅샷 시스템**
  - 중요한 시점의 백업 스냅샷 보관
  - 사용자가 수동으로 스냅샷 생성 가능

- [ ] **버전 히스토리**
  - 과거 버전 목록 표시
  - 특정 버전으로 롤백 기능

- [ ] **자동 정리**
  - 오래된 백업 파일 자동 삭제
  - 보관 기간 설정 (예: 최근 30일)
  - 스냅샷은 영구 보관

#### 4.3 다중 계정 지원
**목표**: 여러 Google 계정 사용 가능

- [ ] **계정 전환**
  - 여러 계정 등록 및 전환
  - 계정별 독립적인 백업

- [ ] **계정별 데이터 분리**
  - IndexedDB에 계정 정보 저장
  - 동기화 시 활성 계정 사용

---

### Phase 5: 모니터링 및 안정화 (1주)

#### 5.1 에러 처리 및 로깅
**목표**: 문제 발생 시 빠른 진단 및 해결

- [ ] **에러 로깅**
  - 동기화 실패 원인 상세 기록
  - 개발자 콘솔에 구조화된 로그

- [ ] **사용자 친화적 에러 메시지**
  - 기술적 용어 대신 쉬운 설명
  - 문제 해결 방법 제시

- [ ] **자동 재시도**
  - 일시적 오류 시 자동 재시도
  - 최대 재시도 횟수 제한

#### 5.2 테스트 및 검증
**목표**: 안정성 확보

- [ ] **시나리오 테스트**
  - 여러 디바이스에서 동시 편집
  - 오프라인 → 온라인 전환
  - 네트워크 불안정 환경

- [ ] **데이터 무결성 검증**
  - 동기화 후 데이터 일치 확인
  - 체크섬 또는 해시 비교

- [ ] **성능 모니터링**
  - 동기화 소요 시간 측정
  - 네트워크 사용량 모니터링

---

### Phase 6: 저장소 백엔드 확장 (ipdisk 등)

**목표**: Google Drive 외에 ipdisk NAS 등 다른 백업 저장소를 지원하여 사용자에게 선택권을 제공합니다.

#### 6.1 저장소 서비스 추상화
**목표**: 여러 백업 서비스를 동일한 방식으로 처리할 수 있는 유연한 구조 마련

- [ ] **`StorageService` 인터페이스 정의**
  - 모든 저장소 서비스가 구현해야 할 공통 기능(메서드) 정의 (예: `signIn`, `signOut`, `upload`, `download`, `listFiles`).
  - 이를 통해 `syncManager`가 특정 서비스(Google Drive)에 종속되지 않도록 분리.

- [ ] **기존 `GoogleDriveService` 리팩토링**
  - `googleDrive.js`가 새로 정의된 `StorageService` 인터페이스를 구현하도록 구조 변경.

#### 6.2 ipdisk NAS 서비스 구현
**목표**: ipdisk NAS와 연동하여 파일을 백업하고 복원하는 신규 서비스 개발

- [ ] **`IpdiskNasService` 클래스 생성**
  - `StorageService` 인터페이스를 구현.
  - 사용자가 입력한 NAS 주소, 계정 정보를 받아 인증 처리.
  - `fetch` API를 사용하여 NAS의 파일 API와 통신 (파일 업로드/다운로드/목록 조회).

- [ ] **NAS API 및 CORS 이슈 확인**
  - **(선결과제)** ipdisk NAS가 제공하는 파일 관리 API의 명세 확인 필요 (HTTP/WebDAV 등).
  - **(중요)** 웹 브라우저에서 NAS로 직접 API를 호출하려면 NAS 서버의 **CORS(Cross-Origin Resource Sharing) 설정이 필수적**. 이는 사용자 측의 NAS 서버 설정 변경이 필요한 부분임을 명확히 인지.

#### 6.3 UI/UX 및 로직 수정
**목표**: 사용자가 백업 서비스를 선택하고 관리할 수 있도록 UI 개선

- [ ] **설정 화면 개선 (`Settings.jsx`)**
  - 백업 저장소를 'Google Drive'와 'ipdisk' 중에서 선택하는 라디오 버튼/드롭다운 추가.
  - 'ipdisk' 선택 시, NAS 주소, 사용자 이름, 비밀번호를 입력할 수 있는 폼 필드 제공.

- [ ] **`syncManager` 및 `BackupPanel` 로직 수정**
  - 사용자가 설정에서 선택한 저장소 서비스에 따라 동적으로 해당 서비스(`GoogleDriveService` 또는 `IpdiskNasService`)의 인스턴스를 사용하도록 변경.
  - `StorageServiceFactory` 같은 팩토리 패턴을 도입하여 서비스 인스턴스 생성을 중앙에서 관리하는 것을 고려.

---

## 🔧 기술 스택 및 도구

### 필요한 라이브러리
- **`workbox`** (Service Worker 관리 - PWA 오프라인 지원 강화)
- **`idb`** (IndexedDB 래퍼 - 이미 Dexie 사용 중이므로 활용)
- **`pako`** (gzip 압축/해제)
- **`diff-match-patch`** (증분 동기화용 diff 알고리즘)

### API 활용
- **Google Drive API v3** (파일 업로드/다운로드, 변경 감지)
- **Google Drive Changes API** (원격 변경 사항 추적)
- **Navigator Online/Offline Events** (네트워크 상태 감지)
- **IndexedDB Observer** (Dexie hooks로 로컬 변경 감지)

---

## 📊 우선순위 매트릭스

| 단계 | 기능 | 중요도 | 난이도 | 우선순위 |
|------|------|--------|--------|----------|
| Phase 1 | 앱 시작 시 자동 동기화 | 🔴 High | 🟢 Low | ⭐⭐⭐⭐⭐ |
| Phase 1 | 네트워크 상태 체크 | 🟡 Medium | 🟢 Low | ⭐⭐⭐⭐ |
| Phase 2 | 변경 사항 추적 | 🔴 High | 🟡 Medium | ⭐⭐⭐⭐⭐ |
| Phase 2 | 충돌 해결 | 🔴 High | 🔴 High | ⭐⭐⭐⭐ |
| Phase 3 | 상태 인디케이터 | 🟡 Medium | 🟢 Low | ⭐⭐⭐⭐ |
| Phase 3 | 설정 페이지 | 🟡 Medium | 🟢 Low | ⭐⭐⭐ |
| Phase 4 | 증분 동기화 | 🟡 Medium | 🔴 High | ⭐⭐⭐ |
| Phase 4 | 버전 관리 | 🟢 Low | 🟡 Medium | ⭐⭐ |
| Phase 5 | 테스트 | 🔴 High | 🟡 Medium | ⭐⭐⭐⭐⭐ |

---

## 🚀 빠른 시작 플랜 (MVP)

최소 기능으로 빠르게 자동 동기화를 구현하려면:

### Week 1: 기본 자동 동기화
1. ✅ `SyncManager` 클래스 생성
2. ✅ 앱 시작 시 자동 동기화 트리거
3. ✅ 간단한 상태 인디케이터 추가
4. ✅ 네트워크 상태 체크

### Week 2: 사용자 경험 개선
1. ✅ 설정 페이지 (자동 동기화 ON/OFF)
2. ✅ 에러 처리 개선
3. ✅ 토스트 알림 최적화
4. ✅ 기본 테스트

**이후**: Phase 2부터 순차적으로 구현

---

## 💡 구현 팁

### 1. **점진적 롤아웃**
- 기존 수동 백업 기능은 유지
- 자동 동기화를 선택적 기능으로 시작
- 사용자 피드백 수집 후 개선

### 2. **데이터 안전성 최우선**
- 동기화 실패 시 로컬 데이터 보존
- 백업 전 로컬 데이터 검증
- 복원 시 현재 데이터 임시 백업

### 3. **배터리 및 데이터 사용 고려**
- 모바일 환경에서는 Wi-Fi에서만 자동 동기화
- 배터리 절약 모드 시 동기화 빈도 감소
- 사용자 설정으로 제어 가능

### 4. **명확한 피드백**
- 동기화 상태를 항상 표시
- 문제 발생 시 명확한 해결 방법 제시
- 성공 시에도 사용자에게 알림 (조용하게)

---

## 🎉 기대 효과

### 사용자 관점
- ✅ 디바이스 간 자동 동기화로 편의성 향상
- ✅ 데이터 손실 걱정 없이 안전한 백업
- ✅ 별도 작업 없이 항상 최신 상태 유지

### 기술적 관점
- ✅ 확장 가능한 동기화 아키텍처
- ✅ 네트워크 효율성 개선
- ✅ 오프라인 우선 PWA로 발전

---

## 📝 참고 자료

- [Google Drive API - Changes](https://developers.google.com/drive/api/guides/manage-changes)
- [Service Worker - Background Sync](https://developer.chrome.com/docs/workbox/modules/workbox-background-sync/)
- [IndexedDB Best Practices](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [Offline First Design](https://offlinefirst.org/)

---

> **다음 단계**: 이 로드맵을 검토하신 후, 어떤 Phase부터 시작할지 결정해주세요. MVP로 빠르게 시작하거나, 특정 기능에 집중할 수도 있습니다!
